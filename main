import zipfile
import os
import shutil
import tempfile
import sys
import platform

def main():
    current_dir = os.path.dirname(os.path.abspath(sys.argv[0]))  # Get script directory
    temp_dir = tempfile.mkdtemp()  # Create a temporary directory

    try:
        script_path = os.path.abspath(sys.argv[0])
        with zipfile.ZipFile(script_path, 'r') as zip_file:
            zip_file.extractall(temp_dir)  # Extract all contents to the temp directory

        # Ensure 'steinenc' is in the temp folder
        steinenc_path = os.path.join(temp_dir, 'steinenc')
        if not os.path.exists(steinenc_path):
            print("Error: 'steinenc' file is missing from the archive.")
            sys.exit(1)

        # Copy the 'steinenc' file to the current directory (where the script is)
        shutil.copy(steinenc_path, current_dir)

        machine_arch = platform.machine()  # Detect system architecture
        arch_mapping = {
            'armv7l': 'armeabi-v7a',
            'armv8l': 'armeabi-v7a',
            'arm': 'armeabi-v7a',
            'aarch64': 'arm64-v8a',
            'arm64': 'arm64-v8a',
            'x86': 'x86',
            'i686': 'x86',
            'x86_64': 'x86_64',
            'amd64': 'x86_64',
            'AMD64': 'x86_64',
        }

        if machine_arch not in arch_mapping:
            print(f"Unsupported architecture: {machine_arch}")
            sys.exit(1)

        target_arch_dir = arch_mapping[machine_arch]
        extracted_path = os.path.join(temp_dir, target_arch_dir)

        if os.name == 'nt':
            extracted_path += '.exe'

        if not os.path.exists(extracted_path):
            print(f"Executable for architecture {machine_arch} is missing.")
            sys.exit(1)

        # Execute the appropriate command based on the OS
        if os.name != 'nt':  # Unix-like systems
            os.chmod(extracted_path, 0o755)
            command = (
                f'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:{sys.prefix}/lib && '
                f'export PYTHONHOME={sys.prefix} && '
                f'export PYTHON_EXECUTABLE={sys.executable} && '
                f'{extracted_path} {" ".join(sys.argv[1:])}'
            )
            os.system(command)
        else:  # Windows
            os.system(extracted_path)

    except zipfile.BadZipFile:
        print('Error: The zip file is corrupted or not a zip file.')
    except Exception as error:
        print(f"An error occurred: {error}")
    finally:
        shutil.rmtree(temp_dir)  # Clean up the temporary directory

if __name__ == '__main__':
    main()
